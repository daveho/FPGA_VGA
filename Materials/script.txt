[1] Hello again!

If you've followed my channel, you know that since 2016 I have been
working on an 8-bit microcomputer system based on the Motorola 6809
CPU. One of my goals for that system is to create a VGA text display.
In the summer of 2024, I designed and implemented a text display using
GALs, dual port static RAM, and various 7400-series logic chips.

To validate the design, I used Logisim Evolution to create simulations
of the various modules on the design. This allowed me to have reasonable
confidence that when I built the circuit, it would work as intended.

Although there were some stumbling blocks along the way, including
some challenging signal integrity issues, I did eventually get the
design to fully work.

This process was lots of fun, and it really allowed me to understand
the problem of designing a text display at a detailed level.

However, the resulting design was not very practical.

Even though using programmable GAL devices allowed me to implement
custom logic to take the place of what likely would have been dozens
of individual logic chips, the resulting design still had a total
of 25 ICs, including two IDT7134 dual port static RAMS in PLCC 52
packages.

Even if I used mostly surface mount ICs, this design would be very
hard to fit on a 15x9 centimeter PCB, which is the standard card size
I am using in the 6809 system. So, it was going to be difficult to
translate my working design into a practical "production" version.

[2] One way to reduce the physical size of the circuit would be
to implement it using a single FPGA. A single Lattice Ultraplus 5K
FPGA, such as the one at the heart of the Upduino 3 development board,
has ample capacity to implement a text display, including embedded
RAM for the video memory.

You may have seen previous videos where I tried and failed to make
progress on implementing a display controller using an FPGA.
Even though I feel relatively confident in designing, building, and
debugging digital circuits, something about programming FPGAs
just didn't click for me. I've been experimenting with FPGAs and
Verilog off and on for almost 5 years, and although I have learned
a fair amount, I haven't exactly been making rapid progress.

What I realized after getting my GAL-based display controller to
work was that I had already done the hard part, which is developing
the logic implementing the precise timing needed to rasterize the
contents of a framebuffer.

So, maybe I could "port" the design to Verilog, so that it could work
in an FPGA.

Anyway, I was able to do precisely that. Although I got most of the
design working in an FPGA in a week or so back in 2024, one technical detail took
me more than a year to figure out.

[Obligatory Baymax "I am not fast" clip.]

In this video,

I'll discuss the easy parts of translating the design to Verilog,
including the timing, sync generation, video memory readout, and
pixel generation,

and the harder part, which was implementing an interface to allow
a host system to read and write the contents of video memory.

I'll demonstrate the FPGA-based video controller using an Arduino
to stand in for the host system,

and I'll conclude with my plans for what comes next.

As always, links to the schematic and code are in the video description.

# Part 1: The Easy Stuff

In the original design, I used 7 GAL22V10 devices to generate timing
and control signals.

The Horizontal Count GAL controls the counters used to count the pixels
in each horizontal scanline, and generates timing signals to control
the horizontal sync pulses, fetching character and attribute data from
video memory, and determining pixel visibility.

The Vertical Count GAL controls the counters used to count the scanlines
in each video frame, and generates timing signals to control the vertical
sync pulses and pixel visibility.

The Sync Generation GAL uses the timing signals from the horizontal and
vertical count GALs to generate the horizontal and vertical sync
signals, to provide the precise timing information needed to read
character and attribute data from VRAM, and to rasterize the fetched
characters and attributes.

The Readout Address Generator GAL controls the counters used to generate
the address of the next character or attribute byte to fetch from VRAM.

The VRAM Control GAL generates the chip select and read/write strobe
signals used to read data from and write data to the VRAM chips.

The Pixel Generator GAL controls the registers used to store the
current character and attribute being rendered, and also controls the
shift register used to rasterize the pixels in the current character
row being displayed. The shift register is implemented as a GAL, although
in retrospect at 74ALS166 chip likely would have worked just as well.

In converting the design to Verilog, I simply created a Verilog module
to take the place of each module in the original design. Each Verilog
module subsumes the functionality of one of the GALs in the original design,
along with whatever support chips it controlled. The goal was to
have the Verilog implementation be functionally identical to the
original hardware.

Converting the original design to Verilog was, for the most part,
straightforward.

Each flip-flop and 7400-series register in the original design became
a reg instance in Verilog.

Each counter in the original design also became a reg instance in
Verilog, since Verilog supports addition.

To clock data into a flip-flop or register, the Verilog implementation
does a conditional nonblocking assignment to the register in an always
block sensitive to the desired clock edge.

To take the place of the dual port static RAM chips the original design
uses for video memory, I used the FPGA's block RAMs, expressed in
Verilog as arrays of 8-bit registers. When such arrays are updated
using appropriate control signals and timing, the FPGA synthesis tools
will map them directly onto the underlying block RAM hardware.
Initially, I implemented only the interface needed by the readout
module to allow character and attribute data to be fetched from video
memory, and pre-initialized the video memory contents with a test
image.

In place of the font ROM, I used 4 KB of pre-initialized block RAM
memory.

The input and output signals of each module became input and output
wires in the corresponding Verilog module.

Overall, this conversion process wasn't too hard!

Next, I'll briefly go through some details of the conversion process for
three of the modules.

The Horizontal Count module was originally implemented as three 74ALS163
4-bit counters and a control GAL. The outputs of the GAL were generated
from simple combinational logic as a function of the current state
of the reset signals and the horizontal count bits. For example,
the horizontal count end signal asserted when the end of the scanline
is reached simply tests the bits of the horizontal count to see if they
are equal to an expected value.

In the Verilog implementation of the Horizontal Count module, the
74ALS163 counters are replaced by a 12 bit register, and on each positive
clock edge, its value is either incremented or reset to 0.

Generating control signals is simply a boolean function computed from
the current values of reset and the horizontal count bits. For example,
the horizontal count end signal is asserted when the count register
is equal to the value indicating that the end of the scanline was reached.

The Sync module was originally implemented as a single GAL with registered
outputs. For example, the vertical sync signal sent to the VGA monitor
is generated using a single flip-flop that is updated each clock cycle
based on the the state of the reset signal, the vertical pulse begin and
end signals generated by the Vertical Count module, and the current state
of the flip-flop itself.

The Verilog version of the module is a direct translation of the GAL
equations, using a single reg instance for each flip-flop. The only real
difference compared to the original GAL equations is that we don't need
to worry about explicitly keeping the value of a flip-flop at the same
value if we don't want to update it on a specific clock cycle: that
is simply the default behavior if the conditions are such that none of
the nonblocking assignments to the register are executed.

One of the more complex modules in the original implementation is the
Readout module, which fetches character and attribute data from VRAM
so that it can be rasterized as a series of visible pixels. In the
original implementation, it was realized using 3 74ALS163 4-bit counters
to generate the current memory fetch address, two 74ALS273 8-bit
registers to keep track of the start address for the current row
of characters being rendered, and a GAL to control everything.
The basic idea is that each row of characters is rendered as 16
scanlines, and the same sequence of memory addresses is fetched for each
scanline in a character row. Since each character is 8 pixels wide,
and is rendered from both a character value and an attribute value,
we need to fetch a byte from video memory once every 4 clock cycles,
at least for the visible portion of each scanline. One annoyance in the
original design is that the frame buffer contains 4800 bytes of
data, meaning that 13 bits of address information are needed.
Since the threee 74ALS163 counters have room for only 12 bits, the
GAL uses a flip-flop with some complicated update equations to serve
as a 13th address bit. Overall, there is some fairly tricky logic to
ensure that the readout address and row begin address registers are
updated at exactly the right times.

In the Verilog implementation of the Readout module, things are much
more straightforward. The row begin and read out address registers are
simply 13-bit reg instances. The conditional logic to express when and
how the registers are updated is also much simpler: for example,
the logic to update the row begin address and readout address registers
at the end of a scanline is dramatically simpler.
