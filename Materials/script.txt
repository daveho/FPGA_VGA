[1] Hello again!

If you've followed my channel, you know that since 2016 I have been
working on an 8-bit microcomputer system based on the Motorola 6809
CPU. One of my goals for that system is to create a VGA text display.
In the summer of 2024, I designed and implemented a text display using
GALs, dual port static RAM, and various 7400-series logic chips.

To validate the design, I used Logisim Evolution to create simulations
of the various modules on the design. This allowed me to have reasonable
confidence that when I built the circuit, it would work as intended.

Although there were some stumbling blocks along the way, including
some challenging signal integrity issues, I did eventually get the
design to fully work.

This process was lots of fun, and it really allowed me to understand
the problem of designing a text display at a detailed level.

However, the resulting design was not very practical.

Even though using programmable GAL devices allowed me to implement
custom logic to take the place of what likely would have been dozens
of individual logic chips, the resulting design still had a total
of 25 ICs, including two IDT7134 dual port static RAMS in PLCC 52
packages.

Even if I used mostly surface mount ICs, this design would be very
hard to fit on a 15x9 centimeter PCB, which is the standard card size
I am using in the 6809 system. So, it was going to be difficult to
translate my working design into a practical "production" version.

[2] One way to reduce the physical size of the circuit would be
to implement it using a single FPGA. A single Lattice Ultraplus 5K
FPGA, such as the one at the heart of the Upduino 3 development board,
has ample capacity to implement a text display, including embedded
RAM for the video memory.

You may have seen previous videos where I tried and failed to make
progress on implementing a display controller using an FPGA.
Even though I feel relatively confident in designing, building, and
debugging digital circuits, something about programming FPGAs
just didn't click for me. I've been experimenting with FPGAs and
Verilog off and on for almost 5 years, and although I have learned
a fair amount, I haven't exactly been making rapid progress.

What I realized after getting my GAL-based display controller to
work was that I had already done the hard part, which is developing
the logic implementing the precise timing needed to rasterize the
contents of a framebuffer.

So, maybe I could "port" the design to Verilog, so that it could work
in an FPGA.

Anyway, I was able to do precisely that. Although I got most of the
design working in an FPGA in a week or so back in 2024, one technical detail took
me more than a year to figure out.

[Obligatory Baymax "I am not fast" clip.]

In this video,

I'll discuss the easy parts of translating the design to Verilog,
including the timing, sync generation, video memory readout, and
pixel generation,

and the harder part, which was implementing an interface to allow
a host system to read and write the contents of video memory.

I'll demonstrate the FPGA-based video controller using an Arduino
to stand in for the host system,

and I'll conclude with my plans for what comes next.

As always, links to the schematic and code are in the video description.

# Part 1: The Easy Stuff

In the original design, I used 7 GAL22V10 devices to generate timing
and control signals.

The Horizontal Count GAL controls the counters used to count the pixels
in each horizontal scanline, and generates timing signals to control
the horizontal sync pulses, fetching character and attribute data from
video memory, and determining pixel visibility.

The Vertical Count GAL controls the counters used to count the scanlines
in each video frame, and generates timing signals to control the vertical
sync pulses and pixel visibility.

The Sync Generation GAL uses the timing signals from the horizontal and
vertical count GALs to generate the horizontal and vertical sync
signals, to provide the precise timing information needed to read
character and attribute data from VRAM, and to rasterize the fetched
characters and attributes.

The Readout Address Generator GAL controls the counters used to generate
the address of the next character or attribute byte to fetch from VRAM.

The VRAM Control GAL generates the chip select and read/write strobe
signals used to read data from and write data to the VRAM chips.

The Pixel Generator GAL controls the registers used to store the
current character and attribute being rendered, and also controls the
shift register used to rasterize the pixels in the current character
row being displayed. The shift register is implemented as a GAL, although
in retrospect at 74ALS166 chip likely would have worked just as well.

In converting the design to Verilog, I simply created a Verilog module
to take the place of each module in the original design. Each Verilog
module subsumes the functionality of one of the GALs in the original design,
along with whatever support chips it controlled. The goal was to
have the Verilog implementation be functionally identical to the
original hardware.

Converting the original design to Verilog was, for the most part,
straightforward.

Each flip-flop and 7400-series register in the original design became
a reg instance in Verilog.

Each counter in the original design also became a reg instance in
Verilog, since Verilog supports addition.

To clock data into a flip-flop or register, the Verilog implementation
does a conditional nonblocking assignment to the register in an always
block sensitive to the desired clock edge.

To take the place of the dual port static RAM chips the original design
uses for video memory, I used the FPGA's block RAMs, expressed in
Verilog as arrays of 8-bit registers. When such arrays are updated
using appropriate control signals and timing, the FPGA synthesis tools
will map them directly onto the underlying block RAM hardware.
Initially, I implemented only the interface needed by the readout
module to allow character and attribute data to be fetched from video
memory, and pre-initialized the video memory contents with a test
image.

In place of the font ROM, I used 4 KB of pre-initialized block RAM
memory.

The input and output signals of each module became input and output
wires in the corresponding Verilog module.

Overall, this conversion process wasn't too hard!

Next, I'll briefly go through some details of the conversion process for
three of the modules.

The Horizontal Count module was originally implemented as three 74ALS163
4-bit counters and a control GAL. The outputs of the GAL were generated
from simple combinational logic as a function of the current state
of the reset signals and the horizontal count bits. For example,
the horizontal count end signal asserted when the end of the scanline
is reached simply tests the bits of the horizontal count to see if they
are equal to an expected value.

In the Verilog implementation of the Horizontal Count module, the
74ALS163 counters are replaced by a 12 bit register, and on each positive
clock edge, its value is either incremented or reset to 0.

Generating control signals is simply a boolean function computed from
the current values of reset and the horizontal count bits. For example,
the horizontal count end signal is asserted when the count register
is equal to the value indicating that the end of the scanline was reached.

The Sync module was originally implemented as a single GAL with registered
outputs. For example, the vertical sync signal sent to the VGA monitor
is generated using a single flip-flop that is updated each clock cycle
based on the the state of the reset signal, the vertical pulse begin and
end signals generated by the Vertical Count module, and the current state
of the flip-flop itself.

The Verilog version of the module is a direct translation of the GAL
equations, using a single reg instance for each flip-flop. The only real
difference compared to the original GAL equations is that we don't need
to worry about explicitly keeping the value of a flip-flop at the same
value if we don't want to update it on a specific clock cycle: that
is simply the default behavior if the conditions are such that none of
the nonblocking assignments to the register are executed.

One of the more complex modules in the original implementation is the
Readout module, which fetches character and attribute data from VRAM
so that it can be rasterized as a series of visible pixels. In the
original implementation, it was realized using 3 74ALS163 4-bit counters
to generate the current memory fetch address, two 74ALS273 8-bit
registers to keep track of the start address for the current row
of characters being rendered, and a GAL to control everything.
The basic idea is that each row of characters is rendered as 16
scanlines, and the same sequence of memory addresses is fetched for each
scanline in a character row. Since each character is 8 pixels wide,
and is rendered from both a character value and an attribute value,
we need to fetch a byte from video memory once every 4 clock cycles,
at least for the visible portion of each scanline. One annoyance in the
original design is that the frame buffer contains 4800 bytes of
data, meaning that 13 bits of address information are needed.
Since the threee 74ALS163 counters have room for only 12 bits, the
GAL uses a flip-flop with some complicated update equations to serve
as a 13th address bit. Overall, there is some fairly tricky logic to
ensure that the readout address and row begin address registers are
updated at exactly the right times.

In the Verilog implementation of the Readout module, things are much
more straightforward. The row begin and read out address registers are
simply 13-bit reg instances. The conditional logic to express when and
how the registers are updated is also much simpler: for example,
the logic to update the row begin address and readout address registers
at the end of a scanline is dramatically simpler.

One of the reasons I struggled with FPGA programming previously was that
the signals inside the FPGA can't be probed, so debugging tools like
oscilloscopes and logic analyzers can be used easily. To overcome
this difficulty, FPGA designs should be tested in simulation.

A viewer of a previous video recommended that I check out the John's
Basement youtube channel to learn about how to do simulation in Verilog,
and specifically, how to write Verilog test benches.

A test bench is like a unit test for a Verilog module or modules.
The test bench generates clock and control signals to feed to the modules'
inputs, and checks the generated output signals to make sure they are correct.

Writing test benches was very helpful.

Based on what I learned from the Johns's Basement videos, I was able to
implement test benches for the horizontal count, vertical count, and
readout modules. Knowing how the modules behaved in simulation gave me
confidence that they would work as expected on the actual FPGA.

Within a week or so of starting the FPGA version of the design, it
was producing a correct image, which was very gratifying progress.

# Part 2: The Host Interface

Everything I've described so far was genuinely straightforward.
I had a working design, and I just needed to translate it into Verilog
in a direct way.

However, there was one significant problem remaining. The UP5K's
block RAM is different than the IDT7134 dual port RAM chips I used
in the original design. In particular:

- It's synchronous, meaning that you read and write data on a positive
  clock edge. The IDT7134 is asynchronous, meaning that data transfers
  are controlled entirely by the chip enable and read/write strobes.
  For the display controller, it doesn't really matter too much
  whether the VRAM is synchronous or asynchronous, and for the
  rasterization hardware, synchronous is actually better since the
  timing for VRAM reads is generated by the VGA dot clock.

- It's not truly dual ported, and this actually is a significant
  problem.

The IDT7134 chips are true dual port devices, meaning that both ports
can be used to both read and write data.

The rasterization hardware needs to read from VRAM, and in the original
design, it used one of the two VRAM ports.

The host system --- for example, the 6809 system I'm building --- needs
to both write data to and read data from VRAM. (As an aside, I do realize
that a display controller that only allowed the host system to write to
VRAM would be functional, in the sense that it would allow the host
system to display things on the screen. However, from a software
perspective, it can be very useful to allow the host system to read
the contents of VRAM, so I deemed reading from VRAM to be essential
functionality.) In the original design, the host system used the second
VRAM port, which allowed it to both read from and write to VRAM.

The UP5K block RAM has two ports, but one is only used for reading,
and one is only used for writing. The write port is only needed by the
host system. However, both the rasterization hardware and the host system
need to read from VRAM, so they both want to use the read port.
What can we do about this?

My initial thought was to implement a time-sharing scheme, so that
the rasterization hardware and the host interface could take turns
using the read port.

The rasterization hardware only needs to read port every 4 clock cycles,
so the host system could potentially use the read port on the other
clock cycles.

This idea could work, but it would significantly complicate the design.

I did try to implement this strategy, since I initially thought it wouldn't
be too hard. However, I wasn't able to get it to work. Fortunately,
a much easier solution eventually presented itself.

In the words of Ken Thompson, "When in doubt, use brute force."
In November 2025, I saw an article on Hacker News about a project
to reimplement the IBM PC-XT in an FPGA. It faced a similar
challenge in managing its video memory, and used an ingenious
solution: maintain two copies of video memory. All of the writes
from the host system go to both copies in parallel. This is
trivial to implement: you just connect the clock, write enable,
and write data signals to the write ports of both memory blocks.
The rasterization hardware uses the read port of one block, and
the host system uses the read port of the other block. This is
a minimal effort solution for having two read ports.

This approach does have the disadvantage of doubling the amount of
block RAM needed. However, it's a good tradeoff when the designer
is not particularly skilled at working with FPGAs.

Implementing this approach required a little bit of thought and
effort. The UP5K has 15 KB of block RAM. The font requires 4 KB,
so that leaves 11 KB left over for VRAM. The original design had
two 4KB devices, for a total of 8 KB. Since we didn't have 16 KB
available to have mirrored 8 KB banks, I implemented VRAM as
mirrored 5 KB banks. Each 5 KB bank is actually a 4 KB lower
block and a 1 KB upper block mirrored 4 times in the upper 4 KB of
the VRAM address space.

In the end, implementing mirrored VRAM was fairly easy. The
`vram_5kb` module implements a 5 KB bank with one read port and
one write port, and the `vram_mirrroed` module uses two instances
of `vram_5k` to provide one write port and two read ports.
No changes to the readout and pixel generator modules were needed,
which is good, since they are the most complex part of the overall
design.
