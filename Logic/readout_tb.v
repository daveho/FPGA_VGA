// Testbench for readout module.
// This also (indirectly) tests the sync module.

`include "testbench.vh"

module readout_tb();

  `include "timing.vh"

  // Tick counter (used by  `TICK macro)
  integer ticks;

  // Loop counter (used by `GENCLOCK macro)
  integer k;

  // The testbench just needs to control -RST and CLK
  reg nrst, clk;

  // Outputs generated by the hcount module
  wire hCountEnd, hBeginPulse, hEndPulse, hVisEnd, hBeginActive, hEndActive;

  // Outputs generated by the vcount module
  wire vCountZero, vBeginPulse, vEndPulse, vVisEnd, vCountEnd, vEndActive;
  wire [11:0] vCount;

  // Outputs generated by the sync module
  wire hSync, vSync, hVis, vVis, nVis, vActive;

  // Outputs generated by the Readout module
  wire [12:0] readoutAddr;

  // Instantiate hcount module
  hcount hcount_instance( // Inputs
                          .nrst( nrst ),
                          .clk( clk ),
                          // Outputs
                          .hCountEnd( hCountEnd ),
                          .hBeginPulse( hBeginPulse ),
                          .hEndPulse( hEndPulse ),
                          .hVisEnd( hVisEnd ),
                          .hBeginActive( hBeginActive ),
                          .hEndActive( hEndActive ) );

  // Instantiate vcount module. Note that the hEndPulse signal
  // is used to generate the vCountIncr input to the vcount
  // module.
  vcount vcount_instance( // Inputs
                          .nrst( nrst ),
                          .clk( clk ),
                          .vCountIncr( hEndPulse ),
                          .hCountEnd( hCountEnd ),
                          // Outputs
                         .vCountZero( vCountZero ),
                         .vBeginPulse( vBeginPulse ),
                         .vEndPulse( vEndPulse ),
                         .vVisEnd( vVisEnd ),
                         .vCountEnd( vCountEnd ),
                         .vEndActive( vEndActive ),
                         .vCount( vCount ) );

  // Instantiate sync module
  sync sync_instance( // Inputs
                      .nrst( nrst ),
                      .clk( clk ),
                      .hBeginPulse( hBeginPulse ),
                      .hEndPulse( hEndPulse ),
                      .vBeginPulse( vBeginPulse ),
                      .vEndPulse( vEndPulse ),
                      .hCountEnd( hCountEnd ),
                      .vCountZero( vCountZero ),
                      .hVisEnd( hVisEnd ),
                      .vVisEnd( vVisEnd ),
                      .vCountEnd( vCountEnd ),
                      .vEndActive( vEndActive ),
                      // Outputs
                      .hSync( hSync ),
                      .vSync( vSync ),
                      .hVis( hVis ),
                      .vVis( vVis ),
                      .nVis( nVis ),
                      .vActive( vActive ) );

  // Instantiate readout module
  readout readout_instance( // Inputs
                            .nrst( nrst ),
                            .clk( clk ),
                            .vActive( vActive ),
                            .hBeginActive( hBeginActive ),
                            .hEndActive( hEndActive ),
                            .vCount( vCount[3:0] ),
                            .vSync( vSync ),
                            .hBeginPulse( hBeginPulse ),
                            // Outputs
                            .readoutAddr( readoutAddr ) );

  initial begin
    // set tick count to 0
    ticks = 0;

    // generate dump file we can inspect using gtkwave
    $dumpfile( "readout_tb.vcd" );
    $dumpvars;

    // generate a reset pulse
    `RESET( nrst, clk );

    // advance until vEndPulse is asserted. This should clear
    // the readout address.
    while ( ~vEndPulse ) begin
      `TICK( clk );
    end
    $display( "v end pulse at vcount %d, ticks=%d", vCount, ticks );
    `ASSERT( readoutAddr == 13'd0 );

    // advance until vActive and hBeginActive are both asserted.
    // this marks the beginning of readouot activity (just before the
    // first visible scanline)
    while ( ~(vActive & hBeginActive) ) begin
      `TICK( clk );
    end
    `ASSERT( vActive );
    `ASSERT( hBeginActive );
    $display( "begin activity, vCount=%d, ticks=%d", vCount, ticks );

    // Readout address should still be 0 (this is the first character
    // being fetched from VRAM)
    `ASSERT( readoutAddr == 13'd0 );

    // Advancing 3 cycles should lead to the readout address being
    // incremented (the first attribute fetch), meaning we'll see the
    // incremented readout address on the 4th cycle
    `TICK( clk );
    `ASSERT( readoutAddr == 13'd0 );
    `TICK( clk );
    `ASSERT( readoutAddr == 13'd0 );
    `TICK( clk );
    `ASSERT( readoutAddr == 13'd0 );
    `TICK( clk );
    `ASSERT( readoutAddr == 13'd1 );

    $display( "All tests passed!" );
  end

endmodule
